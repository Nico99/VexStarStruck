#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    PowerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl2,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  pneumLift1,     sensorDigitalOut)
#pragma config(Sensor, dgtl7,  pneumLift2,     sensorDigitalOut)
#pragma config(Motor,  port1,           RightBack,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RightFront,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           RightTread,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           RightWheelTop, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           RightWheelBot, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           LeftWheelTop,  tmotorVex393, openLoop)
#pragma config(Motor,  port7,           LeftWheelBot,  tmotorVex393, openLoop)
#pragma config(Motor,  port8,           LeftTread,     tmotorVex393, openLoop)
#pragma config(Motor,  port9,           LeftFront,     tmotorVex393, openLoop)
#pragma config(Motor,  port10,          LeftBack,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)



/*
OFFICIAL MARIST ROBOTICS CODE:

!!!DISTRIBUTE AT YOUR OWN RISK!!!

By: Matt Haidet "The Real Jesus"

And: Nick "Bluegrass" Banjo, the Sha of Western Kentucky

Fixed by: Jacob Read "The $wagm@ster Himself"

~~~~~isabella~~~~~
*/


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

//int wheelRunning = 0;
int rightWheelPower = 0;
int leftWheelPower = 0;

int leftTarget = 0;
int rightTarget = 0;

int leftSpeed = 0;
int rightSpeed = 0;
float leftError;
float rightError;

bool beeped = false;

byte SHOOTING_MODE = 1;
byte COLLECTING_MODE = -1;
byte currentMode = SHOOTING_MODE;
byte currentMode2 = COLLECTING_MODE;


int getBalancedWheelSpeed(int powerLevel, int actualSpeed, int goalSpeed){
	int newSpeed = powerLevel;
	if(actualSpeed < goalSpeed){
		newSpeed++;
		} else if(actualSpeed > goalSpeed){
		newSpeed--;
	}
	if(newSpeed <= 0 || goalSpeed <= 0){
		newSpeed = 0;
	}
	return newSpeed;
}


void drive(){

	//Variables to hold motor speeds to allow for switching of modes
	int driveRightChannel;
	int driveLeftChannel;
	int driveRightChannel2;
	int driveLeftChannel2;

	if(currentMode == 1){
		driveRightChannel = vexRT(Ch2);
		driveLeftChannel = vexRT(Ch3);
		} else {
		driveRightChannel = vexRT(Ch3);
		driveLeftChannel = vexRT(Ch2);
	}

	if(currentMode2 == 1){
		driveRightChannel2 = vexRT(Ch2Xmtr2);
		driveLeftChannel2 = vexRT(Ch3Xmtr2);
		} else {
		driveRightChannel2 = vexRT(Ch3Xmtr2);
		driveLeftChannel2 = vexRT(Ch2Xmtr2);
	}


	//Speed variables (use arithmetic to determine total motor speed)
	int rf = driveRightChannel;
	int rb = driveRightChannel;
	int lf = driveLeftChannel;
	int lb = driveLeftChannel;

	//Speed variables for partner control (use arithmetic to determine total motor speed)
	int rf2 = driveRightChannel2;
	int rb2 = driveRightChannel2;
	int lf2 = driveLeftChannel2;
	int lb2 = driveLeftChannel2;

	//Motor Speed Declarations
	motor[RightFront] = (rf*currentMode) + (rf2*currentMode2);
	motor[RightBack] = (rb*currentMode) + (rb2*currentMode2);
	motor[LeftFront] = (lf*currentMode) + (lf2*currentMode2);
	motor[LeftBack] = (lb*currentMode) + (lb2*currentMode2);
}


void tread(){
	motor[RightTread] = (vexRT(Btn6U)*127 - vexRT(Btn6D)*127);
	motor[LeftTread] = (vexRT(Btn6U)*127 - vexRT(Btn6D)*127);
}


void wheel(){
	if(vexRT(Btn8D) || vexRT(Btn8DXmtr2)){
		rightTarget = 0;
		leftTarget = 0;
		leftError = 0;
		rightError = 0;
		rightWheelPower = 0;
		leftWheelPower = 0;
	}
	if(vexRT(Btn8U) || vexRT(Btn8UXmtr2)){
		rightTarget = 138;
		leftTarget = 138;
	}
	if(vexRT(Btn8L) || vexRT(Btn8LXmtr2)){
		rightTarget = 110;
		leftTarget = 110;
	}
	if(vexRT(Btn8R)){

	}
	if(vexRT(Btn7R)){
		rightTarget++;
		leftTarget++;
		wait1Msec(100);
	}
	if(vexRT(Btn7L)){
		rightTarget--;
		leftTarget--;
		wait1Msec(100);
	}

	if(rightWheelPower < 0) rightWheelPower = 0;
	if(leftWheelPower < 0) leftWheelPower = 0;

	motor[RightWheelTop] =  rightWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	motor[RightWheelBot] = rightWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	motor[LeftWheelTop] = leftWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	motor[LeftWheelBot] = leftWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;

}


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void allDrive(int speed){
	motor[LeftBack] = speed-20;
	motor[RightBack] = speed;
	motor[LeftFront] = speed-20;
	motor[RightFront] = speed;
}

void stopDrive(){
	allDrive(0);
}

void forwardTime(int time, int speed){
	allDrive(speed);
	wait1Msec(time);
	stopDrive();
}


task getSpeed(){
	while(true){
		leftSpeed = SensorValue(leftEncoder);
		rightSpeed = SensorValue(rightEncoder);
		SensorValue(rightEncoder) = 0;
		SensorValue(leftEncoder) = 0;
		wait1Msec(100);
	}
}

void encoders(){
	leftError = leftTarget - leftSpeed;
	rightError = rightTarget - rightSpeed;

	float kp = 3.5;

	leftWheelPower = (kp*leftError);
	rightWheelPower = (kp*rightError);

/*	if(beeped==false && leftError <= 30 && leftError >= -20 && rightError <= 30 && rightError >=-20){
	PlaySound(soundUpwardTones);
	beeped = true;
	}
	else if(beeped && (leftError > 30 || leftError < -25 || rightError > 30 || rightError < -25)){
	ClearSounds();
	beeped = false;
	} */
}

task speedTrackerLoop(){
	while(true){
		encoders();
	}
}

task speedTrackerLoopPid(){
	while(true){
		encoders();
		motor[RightWheelTop] =  rightWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	  motor[RightWheelBot] = rightWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	  motor[LeftWheelTop] = leftWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;
	  motor[LeftWheelBot] = leftWheelPower; //+ vexRT(Btn8R)*100 + vexRT(Btn8RXmtr2)*100;

	}
}

//Non PID Autonomous (Defualt)
void universal(){
	leftSpeed = 68;
	rightSpeed = 69;
	motor[LeftWheelBot] = leftSpeed;
	motor[LeftWheelTop] = leftSpeed;
	motor[RightWheelTop] = rightSpeed;
	motor[RightWheelBot] = rightSpeed;

	wait1Msec(1500);

	for(int i = 0; i < 4; i++){
		motor[LeftWheelBot] = leftSpeed;
		motor[LeftWheelTop] = leftSpeed;
		motor[RightWheelTop] = rightSpeed;
		motor[RightWheelBot] = rightSpeed;
		wait1Msec(1650 + (i*10));
		motor[RightTread] = 127;
		motor[LeftTread] = 127;
		motor[LeftWheelBot] = leftSpeed;
		motor[LeftWheelTop] = leftSpeed;
		motor[RightWheelTop] = rightSpeed;
		motor[RightWheelBot] = rightSpeed;
		wait1Msec(850);
		motor[RightTread] = 0;
		motor[LeftTread] = 0;
		motor[LeftWheelBot] = leftSpeed;
		motor[LeftWheelTop] = leftSpeed;
		motor[RightWheelTop] = rightSpeed;
		motor[RightWheelBot] = rightSpeed;
	}
	motor[LeftWheelBot] = 0;
	motor[LeftWheelTop] = 0;
	motor[RightWheelTop] = 0;
	motor[RightWheelBot] = 0;
}

//Trolololol I did mess with it - Love Code Nazi :)
void pidAuton2(){
  leftTarget=132;
	rightTarget=132;
	StartTask(getSpeed);
	StartTask(speedTrackerLoopPid);
	wait1Msec(4500);
	// Ball 1
	motor[LeftTread] = 127;
  motor[RightTread] = 127;
  wait1Msec(500);
  motor[LeftTread] = 0;
  motor[RightTread] = 0;
  wait1Msec(1400);
	// Ball 2
	motor[LeftTread] = 127;
  motor[RightTread] = 127;
  wait1Msec(500);
  motor[LeftTread] = 0;
  motor[RightTread] = 0;
  wait1Msec(1350);
	// Ball 3
	motor[LeftTread] = 127;
  motor[RightTread] = 127;
  wait1Msec(500);
  motor[LeftTread] = 0;
  motor[RightTread] = 0;
  wait1Msec(1350);
  // Ball 4
	motor[LeftTread] = 127;
  motor[RightTread] = 127;
  leftTarget=139;
	rightTarget=139;
}

task checkStatus(){
nVolume = 30;
while(true){

if(vexRT(Btn5U) == 1){
	PlaySound(soundUpwardTones);
	wait1Msec(300);
}

if(nLCDButtons == 2){
displayLCDCenteredString(0,"Running");
displayLCDCenteredString(1,"Diagnostics");

wait10Msec(50);
//Battery Level
displayLCDCenteredString(0,"Battery");
PlaySoundFile("BatteryLevels.wav");
if(nImmediateBatteryLevel <= 7.8){
	PlaySoundFile("Critical.wav");
	displayLCDCenteredString(1,"!Critical!");
} else if(nImmediateBatteryLevel <= 10.5){
	PlaySoundFile("Low.wav");
	displayLCDCenteredString(1,"Low");
} else {
	PlaySoundFile("Nominal.wav");
	displayLCDCenteredString(1,"Nominal");
}

//Power Extender
wait10Msec(250);
displayLCDCenteredString(0,"Battery-2");
PlaySoundFile("Secondary.wav");
PlaySoundFile("BatteryLevels.wav");
if(SensorValue(PowerExpander) <= 1500){
	PlaySoundFile("Critical.wav");
	displayLCDCenteredString(1,"!Critical!");
} else if(SensorValue(PowerExpander) <= 2250){
	PlaySoundFile("Low.wav");
	displayLCDCenteredString(1,"Low");
} else {
	PlaySoundFile("Nominal.wav");
	displayLCDCenteredString(1,"Nominal");
}

//Backup battery
wait10Msec(250);
displayLCDCenteredString(0,"Backup Battery");
PlaySoundFile("Auxiliary.wav");
PlaySoundFile("BatteryLevels.wav");
if(BackupBatteryLevel <= 5.0){
	PlaySoundFile("Critical.wav");
	displayLCDCenteredString(1,"!Critical!");
} else if(BackupBatteryLevel <= 7.0){
	PlaySoundFile("Low.wav");
	displayLCDCenteredString(1,"Low");
} else {
	PlaySoundFile("Nominal.wav");
	displayLCDCenteredString(1,"Nominal");
}

//Run Quick Sensors Test
SensorValue[rightEncoder] = 0;
SensorValue[leftEncoder] = 0;
motor[LeftWheelBot] = 100;
motor[LeftWheelTop] = 100;
motor[RightWheelBot] = 100;
motor[RightWheelTop] = 100;
leftTarget = 100;
rightTarget = 100;
wait1Msec(2500);
int val1 = SensorValue[rightEncoder];
int val2 = SensorValue[leftEncoder];
leftTarget = 0;
rightTarget = 0;
//Run Quick Sensors Test
motor[LeftWheelBot] = 0;
motor[LeftWheelTop] = 0;
motor[RightWheelBot] = 0;
motor[RightWheelTop] = 0;
wait1Msec(500);

displayLCDCenteredString(0,"PID Sensors");
PlaySoundFile("Sensors.wav");
if(val1 <= 10 || val2 <= 10){
	PlaySoundFile("Critical.wav");
	displayLCDCenteredString(1,"!Critical!");
} else {
	PlaySoundFile("Nominal.wav");
	displayLCDCenteredString(1,"Nominal");
}
wait10Msec(100);
}
}

}


task autonomous()
{
  pidAuton2();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void lift(){
	SensorValue[pneumLift1] = vexRT(Btn5D);
}


task usercontrol()
{
	StartTask(getSpeed);
	StartTask(checkStatus);
	while (true)
	{
		drive();
		tread();
		wheel();
		lift();
		encoders();
	}
}
//Help Desk is no God, They will never destroy me.
